# HTTP & HTTPS

## HTTP

HTTP(HyperText Transfer Protocol)는 서버/클라이언트 모델을 따라 데이터를 주고 받기 위한 프로토콜(통신 규약)이다.

클라이언트와 서버들은 개별적인 메시지 교환에 의해 통신한다.
보통 브라우저인 클라이언트에 의해 전송되는 메시지를 `요청(requests)`라고 하고, 서버에서 응답으로 전송되는 메시지를 `응답(responses)`라고 한다.

## HTTP 특징

**비연결성(Connectionless)**
</br>
클라이언트 요청에 대해 서버가 응답을 마치면 맺었던 연결을 끊어버리는 성질

</br>

**무상태성(Stateless)**
</br>
비연결성으로 인해 이전의 통신을 인식하지 않는 성질

## HTTP로 제어할 수 있는 것

- 캐시
- origin 제약사항 완화
- 인증
- 프록시와 터널링
- 세샨

## HTTP 흐름

1. 클라이언트와 서버는 TCP 연결을 연다.
2. 클라이언트가 HTTP 메시지를 전송(요청)한다.
3. 서버가 HTTP 메시지를 전송(응답)한다.

## HTTP 메시지

HTTP 메시지는 요청(requests)과 응답(responses) 두 가지 타입이 존재하고 구조는 비슷하다.

</br>

**요청 메시지**

- 시작 줄 : `HTTP 메서드`, 요청 타겟, HTTP 버전
- 헤더
- 본문 : 리소스를 가져오는 요청(GET, HEAD, DELETE, OPTIONS)은 보통 본문이 없다. POST와 같이 리소스 업데이트를 하기 위해 서버에 데이터를 전송할 경우 본문이 존재한다.

</br>

**응답 메시지**

- 상태 줄: 프로토콜 버전, `응답 상태 코드`, 상태 텍스트
- 헤더
- 본문

</br>

## HTTP 요청 메서드

클라이언트가 서버로 자원을 요청할 때, 어떠한 목적을 갖는 행위인지 HTTP 메서드를 통해 명시한다.

- POST : 특정 리소스에 엔티티를 제출한다. (Create)
- GET : 특정 리소스의 표시를 요청한다. (Read)
- PUT : 목적 리소스 모든 현재 표시를 요청한다. (Update)
- DELETE : 특정 리소스를 삭제한다. (Delete)
- OPTIONS : 목적 리소스의 통신을 설정할 때 사용한다.
- PATCH : 리소스의 부분만을 수정할 때 사용한다.
- HEAD : GET 메소드의 요청과 동일한 응답을 요구하지만, 본문을 포함하지 않는다.
- CONNECT : 목적 리소스로 식별되는 서버로의 터널을 맺는다.

## HTTP 응답 상태 코드

서버가 클라이언트에게 응답을 할때, HTTP 요청이 성공적을 완료되었는지 실패했는지를 알려준다. 총 5개의 그룹으로 나눌 수 있다.

- 1xx(조건부 응답) : 요청을 받았으며 작업을 계속한다는 의미
- 2xx(성공) : 요청을 성공적으로 받았고, 수용함을 의미
- 3xx(리다이렉션 완료) : 요청 완료를 위해 추가 작업 조치가 필요함을 의미
- 4xx(요청 오류) : 요청의 문법이 잘못되었거나, 요청을 처리할 수 없음을 의미
- 5xx(서버 오류) : 서버가 명백히 유효한 요청에 대해 충족을 실패했음을 의미

</br>

# HTTPS

기존 HTTP 프로토콜은 다음과 같은 단점들이 존재한다.

- 평문 통신이기에 도청이 가능
- 완전성을 증명할 수 없기 때문에 변조가 가능
- 통신 상대를 확인하지 않기 때문에 위장이 가능

</br>

HTTPS(HyperText Transfer Protocol Secure)는 HTTP 프로토콜의 단점을 보완하기 위해 메시지를 암호화한 것이다.

### 암호화 방식

**대칭키(Symmetric Key)**
</br>
암호화와 복호화에 같은 암호키(대칭키)를 사용하는 방식이다.

</br>

**공개키(Public Key)**
</br>
자신이 가지고 있는 고유한 암호키(비밀키)로만 복호화할 수 있는 암호키(공개키)를 대중에 공개하는 방식이다.

> CA(Certificate Authority) : 공개키를 인증해주는 공인된 민간기업

</br>

위 두가지 방식을 혼합해 사용하는 것이 HTTPS 프로토콜의 암호화 방식이다. 대칭키를 주고받을 때만 공개키 암호화 방식을 사용하고 이후에는 계속 대칭키 암호화 방식으로 통신한다.

```
A : 클라이언트
B : 서버

1. A가 B의 공개키로 암호화 통신에 사용할 대칭키를 암호화하고 B에게 보냄
2. B는 암호문을 받고, 자신의 비밀키로 복호화함
3. B는 A로부터 얻은 대칭키로 A에게 보낼 평문을 암호화하여 A에게 보냄
4. A는 자신의 대칭키로 암호문을 복호화함
5. 앞으로 이 대칭키로 암호화를 통신함
```
